---
id: 2257
title: MinusOne
lang: ru
level: medium
tags: math
---

## Проблема

Вы получаете на входе число (всегда положительное).
Ваш тип должен вернуть то же число, только на единицу меньше.
Например:

```typescript
type Zero = MinusOne<1>; // 0
type FiftyFour = MinusOne<55>; // 54
```

## Решение

Эта задача и вправду довольно сложная.
TypeScript не может ничего предложить для работы с числами - ничего!

Поэтому, мы должны как-то найти обходной путь для реализации такой математической операции.
И, поймите, что это вряд ли будет отличное решение и использовать его как пример для подражания вряд ли получится.

Я начал с того, что спросил себя.
Были ли у нас случаи, когда мы работали с числовыми литералами, но без использования самих литералов.
И, как оказалось, да.
Мы использовали кортежи.

У нас уже были задачи, в которых мы работали с кортежами и узнавали длину этих кортежей.
Помните синтаксис для этого?
Это было очень просто - мы обращались к свойству `length`, которое и возвращало нам числовой тип литерал.

Поэтому я подумал, а что если мы создадим кортеж нужной нам длины и выведем его часть без последнего элемента.
А после, возьмем длину этого выведенного кортежа.

Давайте начнём с вспомогательного типа, который будет нам создавать кортеж нужной длины.
Назовём его `Tuple`:

```typescript
type Tuple<L extends number, T extends unknown[] = []> = never;
```

Он принимает в качестве аргументов длину кортежа и временный аккумулятор.
Этот аккумулятор будет накапливать кортеж, пока мы не получим кортеж нужной длины.
Чтобы эту проверку реализовать, обратимся к свойству `length` и сравним его с требуемым:

```typescript
type Tuple<L extends number, T extends unknown[] = []> = T["length"] extends L
  ? never
  : never;
```

Как только мы получили кортеж нужной длины - возвращаем его:

```typescript
type Tuple<L extends number, T extends unknown[] = []> = T["length"] extends L
  ? T
  : never;
```

Но, если же мы не получаем кортеж нужной длины, нам нужно добавить к нему ещё один элемент.
И продолжать так стоит до тех пор, пока не получим ожидаемую длину кортежа:

```typescript
type Tuple<L extends number, T extends unknown[] = []> = T["length"] extends L
  ? T
  : Tuple<L, [...T, unknown]>;
```

Теперь, если мы вызовем наш тип с параметром `5`, например, то мы получим кортеж длиной в 5 элементов и типа `unknown`.
Если же мы обратимся к свойству `length` на этом кортеже, то мы получим числовой литерал - `5`.
То что и нужно было.

Как же достать литерал `4` из такого кортежа?
Вывести кортеж, длина которого 5, но без последнего элемента.
Другими словами, кортеж на один элемент будет короче.

```typescript
type MinusOne<T extends number> = Tuple<T> extends [...infer L, unknown]
  ? never
  : never;
```

Используя такую конструкцию, мы получим в тип параметре `L` кортеж без последнего его элемента.
Всё что остается сделать - это вернуть длину выведенного кортежа.

```typescript
type MinusOne<T extends number> = Tuple<T> extends [...infer L, unknown]
  ? L["length"]
  : never;
```

Таким образом, мы реализовали некое подобие математической операции в системе типов.
Например, вызывая наш тип с параметром `5`, мы получим числовой литерал `4`.

```typescript
type Tuple<L extends number, T extends unknown[] = []> = T["length"] extends L
  ? T
  : Tuple<L, [...T, unknown]>;
type MinusOne<T extends number> = Tuple<T> extends [...infer L, unknown]
  ? L["length"]
  : never;
```

Но!
Большое "но"!
В последних версиях TypeScript, они добавили проверку на количество рекурсивных вызовов.
Поэтому, если честно, мы не пройдём тесты, в которых используются числа больше 50.
Так что это решение сложно назвать решением.

Если у вас есть идеи получше, не стесняйтесь, пишите их с объяснениями в комментариях ниже.
Спасибо!

## Что почитать

- [Дженерики](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [Индексные типы доступа](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
- [Условные типы](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
- [Выведение в условных типах](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
- [Рекурсивные условные типы](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
- [Вариативные типы](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
