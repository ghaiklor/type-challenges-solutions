---
id: 1978
title: Percentage Parser
lang: ru
level: medium
tags: parser
---

## Проблема

Реализовать тип `PercentageParser<T extends string>`. Этот тип должен разбить
строку на три элемента, согласно `/^(\+|\-)?(\d*)?(\%)?$/`.

Структура этих элементов выглядит следующим образом: `[+ или -, число, %]`. В
случае, если совпадения нет, нужно вернуть пустую строку. Например:

```typescript
type PString1 = "";
type PString2 = "+85%";
type PString3 = "-85%";
type PString4 = "85%";
type PString5 = "85";

type R1 = PercentageParser<PString1>; // expected ['', '', '']
type R2 = PercentageParser<PString2>; // expected ["+", "85", "%"]
type R3 = PercentageParser<PString3>; // expected ["-", "85", "%"]
type R4 = PercentageParser<PString4>; // expected ["", "85", "%"]
type R5 = PercentageParser<PString5>; // expected ["", "85", ""]
```

## Решение

Синтаксический разбор строк это очень интересная задача (как для меня). Жаль
только, что мы не сможем добиться хорошего решения в этом случае. Так как всё
что у нас есть это только система типов TypeScript.

Нам нужно разбить строку на три компонента: знак числа, число, знак процента.
Чтобы упростить решение, давайте реализуем их как отдельные типы. Первый тип
будет возвращать знак числа. Второй будет возвращать само число, а третий - знак
процента.

Начнём с первого типа. Нам нужно проверить, что первый символ в строке это знак
плюса или минуса. Чтобы этого достичь, нам нужно сначала вывести этот первый
символ.

```typescript
type ParseSign<T extends string> = T extends `${infer S}${any}` ? never : never;
```

Имея первый символ в тип параметре `S`, мы можем проверить плюс это или минус.
Если это плюс или минус, то возвращаем тип параметр `S`, возвращаем знак, что мы
вывели. Во всех остальных случаях возвращаем пустую строку, согласно постановке
задачи.

```typescript
type ParseSign<T extends string> = T extends `${infer S}${any}`
  ? S extends "+" | "-"
    ? S
    : ""
  : "";
```

Таким образом, мы реализовали тип, который может распознать и вернуть знак
числа. Теперь, сделаем то же самое со знаком процента.

Для начала, проверим, а есть ли символ процента в конце строки.

```typescript
type ParsePercent<T extends string> = T extends `${any}%` ? never : never;
```

В случае, если символ процента присутствует в конце строки - возвращаем символ
процента. Во всех остальных случаях возвращаем пустую строку.

```typescript
type ParsePercent<T extends string> = T extends `${any}%` ? "%" : "";
```

Имея два типа, два анализатора, которые возвращают знаки, мы можем начать думать
о числе. Нам нужно вывести число, которое стоит между этими знаками. Проблема
заключается в том, что эти знаки опциональные.

Чтобы реализовать поддержку опциональных знаков, нам нужно проверять их наличие.
То есть нам нужно проверять, если присутствует знак числа, то пропустить его и
взять число. И так далее. А проблема в том, что если мы этого не сделаем, то в
наше число попадут ненужные нам знаки.

Но у нас же эта логика уже реализована в наших других типах. Всё что нам нужно
это правильно их совместить.

```typescript
type ParseNumber<T extends string> =
  T extends `${ParseSign<T>}${infer N}${ParsePercent<T>}` ? never : never;
```

Видите что происходит? Сначала, мы анализируем случай со знаком числа, используя
ранее написанный тип. Если знак числа присутствует, тип его возвращает и делает
частью тип литерала. А значит, он не попадет в часть, которая выводит число.

То же самое мы проделываем и со знаком процента. Если процент присутствует, тип
его нам возвращает и делает частью строчного тип литерала. Это не дает ему
попасть в часть с выведением числа.

В результате мы остаемся только с самим числом, которое мы и получаем через
выведение типов. Нам остается его только вернуть из условного типа.

```typescript
type ParseNumber<T extends string> =
  T extends `${ParseSign<T>}${infer N}${ParsePercent<T>}` ? N : "";
```

Вы, наверняка, уже догадываетесь, как мы можем это использовать для решения
задачи. Как сказано в условии, нам нужно вернуть кортеж с тремя элементами. А у
нас как раз есть три типа!

```typescript
type PercentageParser<A extends string> = [
  ParseSign<A>,
  ParseNumber<A>,
  ParsePercent<A>,
];
```

Мои поздравления! Мы получили простейший "синтаксический анализатор" с
использованием системы типов.

## Что почитать

- [Условные типы](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
- [Выведение в условных типах](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
- [Строчные тип литералы](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)
