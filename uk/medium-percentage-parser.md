---
id: 1978
title: Percentage Parser
lang: uk
level: medium
tags: parser
---

## Завдання

Реалізувати тип `PercentageParser<T extends string>`.
Цей тип повинен розбити рядок на три елементи, відповідно `/^(\+|\-)?(\d*)?(\%)?$/`.

Структура цих елементі виглядає наступним чином: `[+ или -, число, %]`.
У випадку, якщо збігів немає, потрібно повернути порожній рядок.
Наприклад:

```typescript
type PString1=''
type PString2='+85%'
type PString3='-85%'
type PString4='85%'
type PString5='85'

type R1=PercentageParser<PString1> // expected ['', '', '']
type R2=PercentageParser<PString2> // expected ["+", "85", "%"]
type R3=PercentageParser<PString3> // expected ["-", "85", "%"]
type R4=PercentageParser<PString4> // expected ["", "85", "%"]
type R5=PercentageParser<PString5> // expected ["", "85", ""]
```

## Розв'язок

Синтаксичний розбір рядків це дуже цікава задача (як на мене).
Шкода тільки, що ми не зможемо домогтися гарного розв'язку в цьому випадку.
Так як все, що у нас є, це тільки система типів TypeScript.

Нам потрібно розбити рядок на три компоненти: знак числа, число, знак відсотка.
Щоб спростити розв'язок, давайте реалізуємо їх як окремі типи.
Перший тип буде повертати знак числа.
Другий буде повертати саме число, а третій - знак відсотка.

Почнемо з першого типу.
Нам потрібно перевірити, що перший символ в рядку це знак плюса або мінуса.
Щоб цього досягнути, нам потрібно спочатку вивести цей перший символ.

```typescript
type ParseSign<T extends string> = T extends `${infer S}${any}`
  ? never
  : never
```

Маючи перший символ в тип параметрі `S`, ми можемо перевірити плюс це чи мінус.
Якщо це плюс чи мінус, то повертаємо тип параметр `S` - знак, що ми вивели.
У всіх інших випадках повертаємо порожній рядок, відповідно до умови завдання.

```typescript
type ParseSign<T extends string> = T extends `${infer S}${any}`
  ? S extends '+' | '-' ? S : ''
  : ''
```

Таким чином, ми реалізували тип, який може розпізнати й повернути знак числа.
Тепер, зробимо те ж саме зі знаком відсотка.

Для початку, перевіримо, чи є символ відсотка в кінці рядка.

```typescript
type ParsePercent<T extends string> = T extends `${any}%`
  ? never
  : never
```

У випадку, якщо символ відсотка присутній в кінці рядка - повертаємо символ відсотка.
У всіх інших випадках повертаємо порожній рядок.

```typescript
type ParsePercent<T extends string> = T extends `${any}%`
  ? '%'
  : ''
```

Маючи два типи, два аналізатора, які повертають знаки, ми можемо почати думати про число.
Нам потрібно вивести число, яке стоїть між цими знаками.
Проблема полягає в тому, що ці знаки опціональні.

Щоб реалізувати підтримку опціональних знаків, нам потрібно перевірити їх наявність.
Тобто нам потрібно перевірити, і якщо присутній знак числа, то пропустити його й взяти саме число.
І так далі.
А проблема в тому, що якщо ми цього не зробимо, то в наше число потраплять непотрібні нам знаки.

Але у нас ця логіка вже реалізована в наших інших типах.
Все що нам потрібно це правильно їх зіставити.

```typescript
type ParseNumber<T extends string> = T extends `${ParseSign<T>}${infer N}${ParsePercent<T>}`
  ? never
  : never
```

Бачите що відбувається?
Спочатку, ми аналізуємо випадок зі знаком числа, використовуючи раніше написаний тип.
Якщо знак числа присутній, тип його повертає й робить частиною тип літералу.
Отже, він не потрапляє в частину, яка виводить число.

Те ж саме ми робимо і з знаком відсотка.
Якщо відсоток присутній, тип його нам повертає й робить частиною рядкового тип літералу.
Це не дає йому потрапити в частину з виведенням числа.

В результаті ми залишаємося тільки з самим числом, яке ми й отримуємо через виведення типів.
Нам тільки залишається повернути його з умовного типу. 

```typescript
type ParseNumber<T extends string> = T extends `${ParseSign<T>}${infer N}${ParsePercent<T>}`
  ? N
  : ''
```

Ви, напевно, вже здогадуєтеся, як ми можемо це використовувати для вирішення завдання.
Як сказано в умові, нам потрібно повернути кортеж з трьома елементами.
А у нас як раз є три типи!

```typescript
type PercentageParser<A extends string> = [
  ParseSign<A>,
  ParseNumber<A>,
  ParsePercent<A>,
]
```

Мої вітання!
Ми отримали найпростіший "синтаксичний аналізатор" з використанням системи типів.

## Посилання

- [Умовні типи](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
- [Виведення в умовних типах](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
- [Рядкові тип літерали](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)
