---
id: 1978
title: Percentage Parser
lang: uk
level: medium
tags: parser
---

## Завдання

Реалізувати тип `PercentageParser<T extends string>`.
Цей тип повинен розбити рядок на три елементи, відповідно `/^(\+|\-)?(\d*)?(\%)?$/`.

Структура цих елементів виглядає наступним чином: `[+ або -, число, %]`.
У випадку, якщо збігів немає, потрібно повернути порожній рядок.
Наприклад:

```typescript
type PString1 = "";
type PString2 = "+85%";
type PString3 = "-85%";
type PString4 = "85%";
type PString5 = "85";

type R1 = PercentageParser<PString1>; // expected ['', '', '']
type R2 = PercentageParser<PString2>; // expected ["+", "85", "%"]
type R3 = PercentageParser<PString3>; // expected ["-", "85", "%"]
type R4 = PercentageParser<PString4>; // expected ["", "85", "%"]
type R5 = PercentageParser<PString5>; // expected ["", "85", ""]
```

## Розв'язок

Синтаксичний розбір рядків це дуже цікава задача (як на мене).
Шкода тільки, що ми не зможемо домогтися гарного розв'язку в цьому випадку.
Так як все, що у нас є, це тільки система типів TypeScript.

Нам потрібно розбити рядок на три компоненти: знак числа, число, знак відсотка.
Щоб спростити розв'язок, давайте реалізуємо їх як окремі типи.
Перший тип буде повертати знак числа.
Другий буде повертати саме число, а третій - знак відсотка.

Почнемо з першого типу.
Нам потрібно перевірити, що перший символ в рядку це знак плюса або мінуса.
Щоб цього досягнути, нам потрібно спочатку вивести цей перший символ.

```typescript
type ParseSign<T extends string> = T extends `${infer S}${any}` ? never : never;
```

Маючи перший символ в тип параметрі `S`, ми можемо перевірити плюс це чи мінус.
Якщо це плюс чи мінус, то повертаємо тип параметр `S` - знак, що ми вивели.
У всіх інших випадках повертаємо порожній рядок, відповідно до умови завдання.

```typescript
type ParseSign<T extends string> = T extends `${infer S}${any}`
  ? S extends "+" | "-"
    ? S
    : ""
  : "";
```

Таким чином, ми реалізували тип, який може розпізнати й повернути знак числа.
Тепер, зробимо те ж саме зі знаком відсотка.

Для початку, перевіримо, чи є символ відсотка в кінці рядка.

```typescript
type ParsePercent<T extends string> = T extends `${any}%` ? never : never;
```

У випадку, якщо символ відсотка присутній в кінці рядка - повертаємо символ відсотка.
У всіх інших випадках повертаємо порожній рядок.

```typescript
type ParsePercent<T extends string> = T extends `${any}%` ? "%" : "";
```

Маючи два типи, два аналізатора, які повертають знаки, ми можемо почати думати про число.
Нам потрібно вивести число, яке стоїть між цими знаками.
Проблема полягає в тому, що ці знаки опціональні.

Щоб реалізувати підтримку опціональних знаків, нам потрібно перевірити їх наявність.
Тобто нам потрібно перевірити, і якщо присутній знак числа, то пропустити його й взяти саме число.
І так далі.
А проблема в тому, що якщо ми цього не зробимо, то в наше число потраплять непотрібні нам знаки.

Але у нас ця логіка вже реалізована в наших інших типах.
Все що нам потрібно це правильно їх зіставити.

```typescript
type ParseNumber<T extends string> =
  T extends `${ParseSign<T>}${infer N}${ParsePercent<T>}` ? never : never;
```

Бачите що відбувається?
Спочатку, ми аналізуємо випадок зі знаком числа, використовуючи раніше написаний тип.
Якщо знак числа присутній, тип його повертає й робить частиною тип літералу.
Отже, він не потрапляє в частину, яка виводить число.

Те ж саме ми робимо і з знаком відсотка.
Якщо відсоток присутній, тип його нам повертає й робить частиною рядкового тип літералу.
Це не дає йому потрапити в частину з виведенням числа.

В результаті ми залишаємося тільки з самим числом, яке ми й отримуємо через виведення типів.
Нам тільки залишається повернути його з умовного типу.

```typescript
type ParseNumber<T extends string> =
  T extends `${ParseSign<T>}${infer N}${ParsePercent<T>}` ? N : "";
```

Ви, напевно, вже здогадуєтеся, як ми можемо це використовувати для вирішення завдання.
Як сказано в умові, нам потрібно повернути кортеж з трьома елементами.
А у нас як раз є три типи!

```typescript
type PercentageParser<A extends string> = [
  ParseSign<A>,
  ParseNumber<A>,
  ParsePercent<A>
];
```

Мої вітання!
Ми отримали найпростіший "синтаксичний аналізатор" з використанням системи типів.

## Посилання

- [Умовні типи](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
- [Виведення в умовних типах](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
- [Рядкові тип літерали](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)
